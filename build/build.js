import * as settings from "./settings.js";
import * as log from "./log.js";
import * as fs from "fs";
import * as path from "path";
import process from "process";

const LOADER_IMPL = `
export const audioContext = new AudioContext();

window.magic_play = play;

export function play(sound) {
    var source = audioContext.createBufferSource();
    source.buffer = asset[sound].audio;
    source.connect(audioContext.destination);
    source.start();
}

export async function loadAll() {
    const response = await fetch('/assets.bin');
    const arrayBuffer = await response.arrayBuffer();
    var URL = window.URL || window.webkitURL;

    for (let assetName in asset) {
        const data = new Uint8Array(arrayBuffer, asset[assetName].offset, asset[assetName].size);
        const attachedBuffer = new Uint8Array(data).buffer;

        if (asset[assetName].blob === "") {
            const blob = new Blob([data], { type: asset[assetName].type });
            asset[assetName].blob = URL.createObjectURL(blob);
            continue;
        }

        if (asset[assetName].audio === "") {
            asset[assetName].audio = await audioContext.decodeAudioData(attachedBuffer);
            continue;
        }

        if (asset[assetName].data === "") {
            asset[assetName].data = data
            continue;
        }

        if (asset[assetName].text === "") {
            asset[assetName].text = new TextDecoder().decode(attachedBuffer);
        }
    }
}`;

const HEADER = '\n// AUTO GENERATED BY MAGIC (bun run magic build) --- DO NOT EDIT THIS FILE.\n\nexport const asset = {\n';

const ASSET_TYPE_EMOJI = ["ðŸ§©", "ðŸŽ¨", "ðŸ”Š"];

export function getType(fileExtension) {
    switch (fileExtension) {
        case "obj":
            return ["model/obj", "text"];
        case "jpg":
            return ["image/jpeg"];
        case "webp":
            return ["image/webp"];
        case "png":
            return ["image/png"];
        case "wav":
            return ["audio/wav", "audio"];
    }
}

export async function build() {
    log.write("\nðŸ›   Building asset bundle...");
    console.time("asset bundle");

    let content = HEADER;
    let blobContents = [];
    let offset = 0;
    let assetCount = [];

    for (let assetType of settings.ASSET_TYPES) {
        var assetsCount = 0;

        const dirPath = path.join(settings.projectPath, settings.config.assets, assetType);
        log.print("\n\nðŸ“¦   Building  |  " + log.CYAN + dirPath);

        try {
            // Using readdirSync here
            const files = fs.readdirSync(dirPath);
            for (let file of files) {
                const filePath = path.join(dirPath, file);
                const fileExtension = path.extname(file).slice(1);
                const assetBuffer = fs.readFileSync(filePath);
                const type = getType(fileExtension);
                log.write("\n" + fileExtension + "  " + filePath);

                content += `    "${path.basename(file, path.extname(file))}": { offset: ${offset}, size: ${assetBuffer.length}, type: "${type[0]}", `;

                // TODO: cleanup this mess
                if (type[1]) {
                    if (type[1] === "text") {
                        content += `text: "" },\n`;
                    }

                    if (type[1] === "audio") {
                        content += `audio: "" },\n`;
                    }
                } else {
                    content += `blob: "" },\n`;
                }

                blobContents.push(assetBuffer);

                offset += assetBuffer.length;
                assetsCount += 1;
            }
        } catch (error) {
            log.error(`processing ${dirPath}: \n` + error);
            // Handle error or continue to next directory
        }

        assetCount.push(assetsCount);
    }

    log.write("\n\n");

    const finalBlob = Buffer.concat(blobContents);
    const assetPath = path.join(settings.projectPath, settings.config.src, 'assets.js');
    fs.writeFileSync(assetPath, content + "};\n" + LOADER_IMPL);
    log.write("ðŸ“¦  âŸ¹   Exported offsets  âŸ¹   " + assetPath + "\n");

    const binaryPath = path.join(settings.projectPath, settings.config.dist, "assets.bin");

    // round to 2 decimal places
    const filesize_mb = finalBlob.length / 1024 / 1024;
    const filesize_rounded = Math.round(filesize_mb * 100) / 100;

    log.write("ðŸ“¦  âŸ¹   Exported binary   âŸ¹   " + binaryPath + "  |  " + filesize_rounded + " mb  |  " + finalBlob.length + " kb" + "\n");

    fs.writeFileSync(binaryPath, finalBlob);

    let totalAssets = 0;
    for (let i = 0; i < assetCount.length; i++) {
        totalAssets += assetCount[i];
    }

    let assetReport = "";
    for (let i = 0; i < assetCount.length; i++) {
        assetReport += "\n" + ASSET_TYPE_EMOJI[i] + "  " + assetCount[i] + "  " + settings.ASSET_TYPES[i];
    }

    log.write("\nTotal assets: " + totalAssets + "\n" + assetReport + "\n");

    console.timeEnd("asset bundle");
}
