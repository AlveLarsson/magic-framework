import * as fs from "fs";
import * as path from "path";

import * as settings from "./settings.js";
import * as log from "./log.js";

const LOADER_IMPL = `
export const audioContext = new AudioContext();
export gain = audioContext.createGain();
gain.connect(audioContext.destination);

var global_volume = 1;

window.magic_setVolume = setVolume;
export function setVolume(volume) {
    global_volume = volume;
}

window.magic_play = play;

export function play(sound, volume = 1, pitch = 1) {
    var source = audioContext.createBufferSource();
    source.buffer = asset[sound].audio;
    source.connect(audioContext.destination);

    gain.gain.value = volume * global_volume;
    source.playbackRate.value = pitch;

    source.connect(gain);
    source.start();
}

export async function loadAll() {
    const response = await fetch('/assets.bin');
    const arrayBuffer = await response.arrayBuffer();
    var URL = window.URL || window.webkitURL;

    for (let assetName in asset) {
        const data = new Uint8Array(arrayBuffer, asset[assetName].offset, asset[assetName].size);
        const attachedBuffer = new Uint8Array(data).buffer;

        if (asset[assetName].blob === "") {
            const blob = new Blob([data], { type: asset[assetName].type });
            asset[assetName].blob = URL.createObjectURL(blob);
            continue;
        }

        if (asset[assetName].audio === "") {
            asset[assetName].audio = await audioContext.decodeAudioData(attachedBuffer);
            continue;
        }

        if (asset[assetName].data === "") {
            asset[assetName].data = data
            continue;
        }

        if (asset[assetName].text === "") {
            asset[assetName].text = new TextDecoder().decode(attachedBuffer);
        }
    }
}`;

const HEADER = '\n// AUTO GENERATED BY MAGIC (bun run magic build) --- DO NOT EDIT THIS FILE.\n\nexport const asset = {\n';

const ASSET_TYPE_EMOJI = ["ðŸ§©", "ðŸŽ¨", "ðŸ”Š"];

export function getType(fileExtension) {
    switch (fileExtension) {
        case "obj":
            return ["model/obj", "text"];
        case "jpg":
            return ["image/jpeg"];
        case "webp":
            return ["image/webp"];
        case "png":
            return ["image/png"];
        case "wav":
            return ["audio/wav", "audio"];
    }
}

export async function build() {
    console.time("asset bundle");

    let content = HEADER;
    let blobContents = [];
    let offset = 0;
    let assetTypes = [];

    for (let assetType of settings.ASSET_TYPES) {
        var assetsCount = 0;

        const dirPath = path.join(settings.projectPath, settings.config.assets, assetType);
        log.write("\n");
        log.print(log.CYAN + dirPath);

        try {
            // Using readdirSync here
            const files = fs.readdirSync(dirPath);
            for (let file of files) {
                const filePath = path.join(dirPath, file);
                const fileExtension = path.extname(file).slice(1);
                const assetBuffer = fs.readFileSync(filePath);
                const type = getType(fileExtension);
                log.print(fileExtension + "  " + filePath);

                content += `    "${path.basename(file, path.extname(file))}": { offset: ${offset}, size: ${assetBuffer.length}, type: "${type[0]}", `;

                // TODO: cleanup this mess
                if (type[1]) {
                    if (type[1] === "text") {
                        content += `text: "" },\n`;
                    }

                    if (type[1] === "audio") {
                        content += `audio: "" },\n`;
                    }
                } else {
                    content += `blob: "" },\n`;
                }

                blobContents.push(assetBuffer);

                offset += assetBuffer.length;
                assetsCount += 1;
            }
        } catch (error) {
            log.error(`processing ${dirPath}: \n` + error);
            // Handle error or continue to next directory
        }

        assetTypes.push(assetsCount);
    }

    log.write("\n");

    let totalAssets = 0;

    for (let i = 0; i < assetTypes.length; i++) {
        totalAssets += assetTypes[i];
    }

    const finalBlob = Buffer.concat(blobContents);
    const assetPath = path.join(settings.projectPath, settings.config.src, 'assets.js');
    fs.writeFileSync(assetPath, content + "};\n" + LOADER_IMPL);
    log.print(totalAssets + " offsets: " + assetPath, log.CYAN);

    const binaryPath = path.join(settings.projectPath, settings.config.dist, "assets.bin");

    // round to 2 decimal places
    const filesize_mb = finalBlob.length / 1024 / 1024;
    const filesize_rounded = Math.round(filesize_mb * 100) / 100;

    log.print(filesize_rounded + "mb (" + finalBlob.length + " kb): " + binaryPath, log.CYAN);

    fs.writeFileSync(binaryPath, finalBlob);

    log.write(log.YELLOW);

    for (let i = 0; i < assetTypes.length; i++) {
        log.write(ASSET_TYPE_EMOJI[i] + " " + assetTypes[i] + " " + settings.ASSET_TYPES[i] + " ");
    }
    log.write(log.RESET + "\n");

    console.timeEnd("asset bundle");
}
